        Шаблоны проектирования. Design Patterns

Книга: Design Patterns: Elements of Reusable Object-Oriented Software.
UML - язык описания процессов и структур.
Редактор диаграмм классов: draw.io
В диаграмме стоят + и - возле полей свойств это означает что метод публичный или приватный.
когда описываем методы, то возле них указывается тип, что метод принимает, тоже + и - и тип возвращаемого
значения.
Есть интерфейс, он подписывается сверху как интерфейс.
Взаимодействие межде классами указывается в виде стрелочек. Что от чего наследуется (сплошная стрелочка с
надписью extend) также есть пунктирная стрелочка, что означает имплементирование от интерфейса.

        Паттерн Singleton

Паттерн, который позволяет поддерживать во всем объекте один единственный экземпляр объекта.
Например подключение к базе.
У этого класса обязательно есть статическое поле, которое хранит экземпляр этого класса, оно приватное.
У него обязательно есть статический метод instance, который ничего не принимает, и возвращает экземпляр.
Также есть конструктор, который обязательно приватный, чтоб нельзя было создать объект снаружи.
Сам экземпляр создается в статическом методе instance, который будет проверять, если экземпляр существует,
то он его будет возвращать, есть нет, то создавать.

class Singleton{
    private static $inst=null;
    private $a;

    public static function instance():Self{
        if(self::inst!==null) return self::inst;
        return self::inst = new self;
    }
    private function __construct(){}

    private function setA($a){
        $this->a = $a;
    }
    private function getA(){
        return $this->a;
    }
}

        //Multiton

В отличие от синглтона позволяет хранить ряд именованных экземпляров.
Статик свойством будет ассоциативный массив с ключом и значением будет экземпляр класса.
В условии мы будем проверять существование экземпляра по ключу, если его не будет, то будем создавать
новый и добавлять его в массив.
Таким образом для каждого экземпляра мы можем задавать исключительно его св-ва, и стучатьсяя к ним через
методы.

class Multiton{
    private static $inst=[];
    private static $a;

    public static function instances(string $key):Self{
        if(isset(self::($inst[$key]))) return self::inst[$key];
        return self::inst[$key] = new self;
    }
    private function __construct(){}

    private function setA($a){
        $this->a = $a;
    }
    private function getA(){
        return $this->a;
    }
}

        Фабричный метод

Используется когда необходимо получить экземпляры в зависимости от какой-либо настройки. Например создание
подключения к базе.

В обоих случаях на экране появится "DB", т.к. в настройке у нас указан MODE = "db" и значит работает
класс DataBaseConnectionCreator.
То есть у нас может быть несколько разных подключений в коде, или к БД или к сфтп, и тогда будут создаваться
настройки специфические под конкретную задачу.

        //Абстрактная фабрика

Очень похожа на фабричный метод, только разница в том, что у нас вместо креатора появляетя понятие
фабрики, которые имеют несколько методов, которые могут потенциально выпускать несколько вариантов
одинаковой продукции.
Пример: виджет фактори, в зависимости от темы, может меняться фабрика и все элементы интерфейса, которые
она создает подменяются под конкретную тему.
Когда еще бывает полезна фабрика. У нас бывает общий интерфейс взаимодействия, но одни объекты зависят
от других, в таком случае для создания семейства объектов используются фабрики.

        //Билдер

Смысл состоит в том, что существует экземпляр класса, который помогает создавать экземпляр
другого класса. Пример соединение с БД. У подключения существует множество полей, которые неудобно
заполнять при помощи сеттеров, есть поля по умолчанию и пр. Создается вспомогательный класс, который
возвращает экземпляр подключения с уже полностью заполненными полями. В этом вспомогательном классе
есть все возможные поля по умолчанию, а также специальные методы, которые позволяют быстро, цепочкой
устанавливать значения. Также создаются методы, которые будут в зависимости от настроек, возвращать
переданные параметры особым образом. После этого создается экземпляр основного класса, и при помощи
билдера туда пробрасываются необходимые нам значения параметров.



